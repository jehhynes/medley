<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>1.4</storyId>
    <title>Core Data Models and Database Schema</title>
    <status>Ready</status>
    <generatedAt>2025-10-20</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/story-1.4.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer</asA>
    <iWant>to establish ALL data models needed for the complete system</iWant>
    <soThat>I can store and retrieve organizational data efficiently across all epics</soThat>
    <tasks>
      <task id="1">Define domain entities - Create User, Organization, Integration, Source, Fragment, Observation, Cluster, Article, Insight, Template in src/Medley.Domain/Entities with proper enums and relationships</task>
      <task id="2">Configure EF Core mappings - Add IEntityTypeConfiguration&lt;T&gt; in src/Medley.Infrastructure/Data/Configurations with pgvector support for Fragment and Observation embeddings</task>
      <task id="3">Create database migrations - Generate and apply migrations for new entities with custom SQL for extensions/indexes</task>
      <task id="4">Implement repository pattern - Create repositories for all entities, register in DI, add unit tests with mocking</task>
      <task id="5">Implement CRUD operations - Add CRUD methods in repositories/services with controller endpoints and comprehensive tests</task>
      <task id="6">Define indexing strategy - Add indexes for critical query paths, ensure HNSW vector indexes for embeddings</task>
      <task id="7">Add validation rules - Implement data annotations, Fluent Validation, database constraints with failure tests</task>
      <task id="8">Create seed data - Implement DbInitializer with sample data including Observation/Insight relationships</task>
      <task id="9">Document multi-tenant considerations - Document tenant scoping strategy and schema impacts</task>
      <task id="10">Comprehensive testing - Unit tests for entities/repositories, integration tests with DatabaseFixture, verify vector operations</task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="1">Entity models created for Users, Organizations, Integrations, Sources, Fragments, Observations, Clusters, Articles, Insights, and Templates</criterion>
    <criterion id="2">Database migrations implemented and tested for all entities with proper relationships</criterion>
    <criterion id="3">Repository pattern implemented for data access abstraction</criterion>
    <criterion id="4">Basic CRUD operations implemented for all core entities</criterion>
    <criterion id="5">Database indexing strategy defined and implemented for performance optimization</criterion>
    <criterion id="6">Data validation rules implemented at entity and database levels</criterion>
    <criterion id="7">Seed data created for development and testing environments</criterion>
    <criterion id="8">Multi-tenant database schema considerations documented</criterion>
    <criterion id="9">Observation class implemented as Fragment variant for business intelligence data, and Insight class as composed document from Observations (parallel to Article/Fragment relationship)</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/solution-architecture.md</path>
        <title>Solution Architecture Document</title>
        <section>Data Architecture</section>
        <snippet>Clean Architecture monolith using ASP.NET Core MVC with PostgreSQL database, Entity Framework Core ORM, and interface abstractions for Database, ORM, AI Processing, and File Storage.</snippet>
      </doc>
      <doc>
        <path>docs/tech-spec-epic-1.md</path>
        <title>Tech Spec: Epic 1 - Foundation &amp; Core Infrastructure</title>
        <section>Data Models (Epic 1)</section>
        <snippet>Core entities include User, Organization, Integration, Source, Fragment with Clean Architecture layers and Entity Framework Core configurations.</snippet>
      </doc>
      <doc>
        <path>docs/PRD.md</path>
        <title>Medley Product Requirements Document</title>
        <section>Non-Functional Requirements</section>
        <snippet>Performance targets: sub-2-second response times, 10,000+ fragments/hour processing, 99.9% uptime SLA with PostgreSQL and pgvector extension.</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>Medley - Epic Breakdown</title>
        <section>Story 1.4: Core Data Models and Database Schema</section>
        <snippet>Establish ALL data models needed for complete system to store and retrieve organizational data efficiently across all epics with proper relationships and indexing.</snippet>
      </doc>
      <doc>
        <path>docs/postgresql-setup.md</path>
        <title>PostgreSQL Setup Guide</title>
        <section>Database Configuration</section>
        <snippet>PostgreSQL 16.0+ setup with pgvector extension for vector similarity operations and HNSW indexing for fragment embeddings.</snippet>
      </doc>
      <doc>
        <path>docs/pgvector-setup.md</path>
        <title>pgvector Extension Setup</title>
        <section>Vector Operations</section>
        <snippet>Configuration for vector embeddings with 1536 dimensions, HNSW indexing strategy, and similarity search operations for Fragment and Observation entities.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>src/Medley.Domain/Entities/BaseEntity.cs</path>
        <kind>entity</kind>
        <symbol>BaseEntity</symbol>
        <lines>1-12</lines>
        <reason>Base class for all domain entities with Guid primary key</reason>
      </artifact>
      <artifact>
        <path>src/Medley.Domain/Entities/Fragment.cs</path>
        <kind>entity</kind>
        <symbol>Fragment</symbol>
        <lines>1-55</lines>
        <reason>Existing Fragment entity with vector embedding support - template for Observation</reason>
      </artifact>
      <artifact>
        <path>src/Medley.Domain/Entities/User.cs</path>
        <kind>entity</kind>
        <symbol>User</symbol>
        <lines>1-35</lines>
        <reason>Existing User entity extending ASP.NET Core Identity</reason>
      </artifact>
      <artifact>
        <path>src/Medley.Application/Interfaces/IRepository.cs</path>
        <kind>interface</kind>
        <symbol>IRepository&lt;T&gt;</symbol>
        <lines>1-25</lines>
        <reason>Generic repository interface pattern to implement for new entities</reason>
      </artifact>
      <artifact>
        <path>src/Medley.Application/Interfaces/IFragmentRepository.cs</path>
        <kind>interface</kind>
        <symbol>IFragmentRepository</symbol>
        <lines>1-25</lines>
        <reason>Specialized repository with vector similarity operations - template for ObservationRepository</reason>
      </artifact>
      <artifact>
        <path>src/Medley.Infrastructure/Data/Repository.cs</path>
        <kind>repository</kind>
        <symbol>Repository&lt;T&gt;</symbol>
        <lines>1-35</lines>
        <reason>Generic repository implementation using Entity Framework Core</reason>
      </artifact>
      <artifact>
        <path>src/Medley.Infrastructure/Data/ApplicationDbContext.cs</path>
        <kind>dbcontext</kind>
        <symbol>ApplicationDbContext</symbol>
        <lines>1-50</lines>
        <reason>Main database context where new entities need to be added</reason>
      </artifact>
      <artifact>
        <path>src/Medley.Infrastructure/DependencyInjection.cs</path>
        <kind>configuration</kind>
        <symbol>DependencyInjection</symbol>
        <lines>1-50</lines>
        <reason>DI registration where new repositories need to be registered</reason>
      </artifact>
    </code>
    <dependencies>
      <dotnet>
        <package name="Microsoft.AspNetCore.Identity.EntityFrameworkCore" version="9.0.10" />
        <package name="Microsoft.EntityFrameworkCore.Design" version="9.0.10" />
        <package name="Microsoft.EntityFrameworkCore.Tools" version="9.0.10" />
        <package name="Npgsql.EntityFrameworkCore.PostgreSQL" version="9.0.4" />
        <package name="Pgvector" version="0.3.2" />
        <package name="Pgvector.EntityFrameworkCore" version="0.2.2" />
        <package name="Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore" version="9.0.10" />
        <package name="Serilog.AspNetCore" version="9.0.0" />
      </dotnet>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint>Clean Architecture: Entities in Medley.Domain, EF configurations in Medley.Infrastructure, services in Medley.Application, UI in Medley.Web</constraint>
    <constraint>Repository pattern: Implement IRepository&lt;T&gt; interface for all entities, register in DI container</constraint>
    <constraint>Vector support: Reuse pgvector setup from Story 1.3 for Fragment.Embedding and new Observation.Embedding</constraint>
    <constraint>Performance: Align with PRD targets (sub-2-second response, 10,000+ fragments/hour, 99.9% uptime)</constraint>
    <constraint>Multi-tenant: Document tenant scoping strategy for per-organization data isolation</constraint>
    <constraint>Testing: Always run tests after code modifications, use transaction rollback for database test isolation</constraint>
  </constraints>
  
  <interfaces>
    <interface>
      <name>IRepository&lt;T&gt;</name>
      <kind>Generic repository interface</kind>
      <signature>Task&lt;T?&gt; GetAsync(int id); IQueryable&lt;T&gt; Query(); Task SaveAsync(T entity);</signature>
      <path>src/Medley.Application/Interfaces/IRepository.cs</path>
    </interface>
    <interface>
      <name>IFragmentRepository</name>
      <kind>Specialized repository with vector operations</kind>
      <signature>Task&lt;IEnumerable&lt;FragmentSimilarityResult&gt;&gt; FindSimilarAsync(float[] embedding, int limit, double? threshold = null);</signature>
      <path>src/Medley.Application/Interfaces/IFragmentRepository.cs</path>
    </interface>
    <interface>
      <name>IUnitOfWork</name>
      <kind>Transaction management interface</kind>
      <signature>Task&lt;int&gt; SaveChangesAsync(); void Dispose();</signature>
      <path>src/Medley.Application/Interfaces/IUnitOfWork.cs</path>
    </interface>
  </interfaces>
  
  <tests>
    <standards>xUnit framework with Moq for mocking. AAA pattern (Arrange, Act, Assert). Database tests use DatabaseFixture with transaction rollback for isolation - never use table truncation. Always run tests after code modifications to verify functionality.</standards>
    <locations>src/tests/Medley.Tests.Domain/, src/tests/Medley.Tests.Application/, src/tests/Medley.Tests.Infrastructure/, src/tests/Medley.Tests.Integration/, src/tests/Medley.Tests.Web/</locations>
    <ideas>
      <test ac="1">Unit tests for all new entity classes (User, Organization, Integration, Source, Fragment, Observation, Cluster, Article, Insight, Template) - validate properties, relationships, constraints</test>
      <test ac="2">Integration tests for EF Core migrations - verify schema creation, relationships, and pgvector mappings using DatabaseFixture</test>
      <test ac="3">Unit tests for repository implementations - mock DbContext, test CRUD operations for all entities</test>
      <test ac="4">Integration tests for repository CRUD operations against real PostgreSQL using DatabaseFixture with transaction rollback</test>
      <test ac="5">Performance tests for indexing strategy - verify query performance with sample data</test>
      <test ac="6">Unit tests for validation rules - test data annotations and constraint enforcement</test>
      <test ac="7">Integration tests for seed data - verify DbInitializer creates proper sample data</test>
      <test ac="9">Unit tests for Observation/Insight relationship - verify many-to-many mapping and vector operations</test>
    </ideas>
  </tests>
</story-context>