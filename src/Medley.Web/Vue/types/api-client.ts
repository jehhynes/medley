//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

export class AiPromptApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(): Promise<AiPromptListDto[]> {
        let url_ = this.baseUrl + "/api/prompts";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<AiPromptListDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AiPromptListDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AiPromptListDto[]>(null as any);
    }

    get(type: PromptType, articleTypeId?: string | null | undefined, fragmentCategoryId?: string | null | undefined): Promise<AiPromptDto> {
        let url_ = this.baseUrl + "/api/prompts/{type}?";
        if (type === undefined || type === null)
            throw new globalThis.Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        if (articleTypeId !== undefined && articleTypeId !== null)
            url_ += "articleTypeId=" + encodeURIComponent("" + articleTypeId) + "&";
        if (fragmentCategoryId !== undefined && fragmentCategoryId !== null)
            url_ += "fragmentCategoryId=" + encodeURIComponent("" + fragmentCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<AiPromptDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AiPromptDto;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AiPromptDto>(null as any);
    }

    createOrUpdate(type: PromptType, request: CreateOrUpdateAiPromptRequest, articleTypeId?: string | null | undefined, fragmentCategoryId?: string | null | undefined): Promise<AiPromptDto> {
        let url_ = this.baseUrl + "/api/prompts/{type}?";
        if (type === undefined || type === null)
            throw new globalThis.Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        if (articleTypeId !== undefined && articleTypeId !== null)
            url_ += "articleTypeId=" + encodeURIComponent("" + articleTypeId) + "&";
        if (fragmentCategoryId !== undefined && fragmentCategoryId !== null)
            url_ += "fragmentCategoryId=" + encodeURIComponent("" + fragmentCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateOrUpdate(_response);
        });
    }

    protected processCreateOrUpdate(response: Response): Promise<AiPromptDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AiPromptDto;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AiPromptDto>(null as any);
    }

    getArticleTypes(): Promise<ArticleTypeDto[]> {
        let url_ = this.baseUrl + "/api/prompts/article-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetArticleTypes(_response);
        });
    }

    protected processGetArticleTypes(response: Response): Promise<ArticleTypeDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ArticleTypeDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ArticleTypeDto[]>(null as any);
    }

    getFragmentCategories(): Promise<FragmentCategoryDto[]> {
        let url_ = this.baseUrl + "/api/prompts/fragment-categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFragmentCategories(_response);
        });
    }

    protected processGetFragmentCategories(response: Response): Promise<FragmentCategoryDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FragmentCategoryDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FragmentCategoryDto[]>(null as any);
    }
}

export class ArticleChatApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getConversation(articleId: string, conversationId?: string | null | undefined): Promise<ConversationDto> {
        let url_ = this.baseUrl + "/api/articles/{articleId}/chat/conversation?";
        if (articleId === undefined || articleId === null)
            throw new globalThis.Error("The parameter 'articleId' must be defined.");
        url_ = url_.replace("{articleId}", encodeURIComponent("" + articleId));
        if (conversationId !== undefined && conversationId !== null)
            url_ += "conversationId=" + encodeURIComponent("" + conversationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetConversation(_response);
        });
    }

    protected processGetConversation(response: Response): Promise<ConversationDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ConversationDto;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ConversationDto>(null as any);
    }

    createConversation(articleId: string, mode?: ConversationMode | undefined): Promise<ConversationDto> {
        let url_ = this.baseUrl + "/api/articles/{articleId}/chat/conversation?";
        if (articleId === undefined || articleId === null)
            throw new globalThis.Error("The parameter 'articleId' must be defined.");
        url_ = url_.replace("{articleId}", encodeURIComponent("" + articleId));
        if (mode === null)
            throw new globalThis.Error("The parameter 'mode' cannot be null.");
        else if (mode !== undefined)
            url_ += "mode=" + encodeURIComponent("" + mode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateConversation(_response);
        });
    }

    protected processCreateConversation(response: Response): Promise<ConversationDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ConversationDto;
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ConversationDto>(null as any);
    }

    getMessages(articleId: string, conversationId: string, limit?: number | null | undefined): Promise<ChatMessageDto[]> {
        let url_ = this.baseUrl + "/api/articles/{articleId}/chat/conversations/{conversationId}/messages?";
        if (articleId === undefined || articleId === null)
            throw new globalThis.Error("The parameter 'articleId' must be defined.");
        url_ = url_.replace("{articleId}", encodeURIComponent("" + articleId));
        if (conversationId === undefined || conversationId === null)
            throw new globalThis.Error("The parameter 'conversationId' must be defined.");
        url_ = url_.replace("{conversationId}", encodeURIComponent("" + conversationId));
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMessages(_response);
        });
    }

    protected processGetMessages(response: Response): Promise<ChatMessageDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ChatMessageDto[];
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChatMessageDto[]>(null as any);
    }

    sendMessage(articleId: string, conversationId: string, request: SendMessageRequest): Promise<SendMessageResponse> {
        let url_ = this.baseUrl + "/api/articles/{articleId}/chat/conversations/{conversationId}/messages";
        if (articleId === undefined || articleId === null)
            throw new globalThis.Error("The parameter 'articleId' must be defined.");
        url_ = url_.replace("{articleId}", encodeURIComponent("" + articleId));
        if (conversationId === undefined || conversationId === null)
            throw new globalThis.Error("The parameter 'conversationId' must be defined.");
        url_ = url_.replace("{conversationId}", encodeURIComponent("" + conversationId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendMessage(_response);
        });
    }

    protected processSendMessage(response: Response): Promise<SendMessageResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SendMessageResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SendMessageResponse>(null as any);
    }

    getToolResultContent(articleId: string, conversationId: string, messageId: string, toolCallId: string): Promise<ToolResultContentResponse> {
        let url_ = this.baseUrl + "/api/articles/{articleId}/chat/conversations/{conversationId}/messages/{messageId}/tool-result/{toolCallId}";
        if (articleId === undefined || articleId === null)
            throw new globalThis.Error("The parameter 'articleId' must be defined.");
        url_ = url_.replace("{articleId}", encodeURIComponent("" + articleId));
        if (conversationId === undefined || conversationId === null)
            throw new globalThis.Error("The parameter 'conversationId' must be defined.");
        url_ = url_.replace("{conversationId}", encodeURIComponent("" + conversationId));
        if (messageId === undefined || messageId === null)
            throw new globalThis.Error("The parameter 'messageId' must be defined.");
        url_ = url_.replace("{messageId}", encodeURIComponent("" + messageId));
        if (toolCallId === undefined || toolCallId === null)
            throw new globalThis.Error("The parameter 'toolCallId' must be defined.");
        url_ = url_.replace("{toolCallId}", encodeURIComponent("" + toolCallId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetToolResultContent(_response);
        });
    }

    protected processGetToolResultContent(response: Response): Promise<ToolResultContentResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ToolResultContentResponse;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ToolResultContentResponse>(null as any);
    }

    completeConversation(articleId: string, conversationId: string): Promise<ConversationStatusResponse> {
        let url_ = this.baseUrl + "/api/articles/{articleId}/chat/conversations/{conversationId}/complete";
        if (articleId === undefined || articleId === null)
            throw new globalThis.Error("The parameter 'articleId' must be defined.");
        url_ = url_.replace("{articleId}", encodeURIComponent("" + articleId));
        if (conversationId === undefined || conversationId === null)
            throw new globalThis.Error("The parameter 'conversationId' must be defined.");
        url_ = url_.replace("{conversationId}", encodeURIComponent("" + conversationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCompleteConversation(_response);
        });
    }

    protected processCompleteConversation(response: Response): Promise<ConversationStatusResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ConversationStatusResponse;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ConversationStatusResponse>(null as any);
    }

    cancelConversation(articleId: string, conversationId: string): Promise<ConversationStatusResponse> {
        let url_ = this.baseUrl + "/api/articles/{articleId}/chat/conversations/{conversationId}/cancel";
        if (articleId === undefined || articleId === null)
            throw new globalThis.Error("The parameter 'articleId' must be defined.");
        url_ = url_.replace("{articleId}", encodeURIComponent("" + articleId));
        if (conversationId === undefined || conversationId === null)
            throw new globalThis.Error("The parameter 'conversationId' must be defined.");
        url_ = url_.replace("{conversationId}", encodeURIComponent("" + conversationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCancelConversation(_response);
        });
    }

    protected processCancelConversation(response: Response): Promise<ConversationStatusResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ConversationStatusResponse;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ConversationStatusResponse>(null as any);
    }
}

export class ArticlesApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getArticleTypes(): Promise<ArticleTypeDto[]> {
        let url_ = this.baseUrl + "/api/articles/types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetArticleTypes(_response);
        });
    }

    protected processGetArticleTypes(response: Response): Promise<ArticleTypeDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ArticleTypeDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ArticleTypeDto[]>(null as any);
    }

    getTree(query?: string | null | undefined, statuses?: number[] | null | undefined, articleTypeIds?: string[] | null | undefined): Promise<ArticleSummaryDto[]> {
        let url_ = this.baseUrl + "/api/articles/tree?";
        if (query !== undefined && query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (statuses !== undefined && statuses !== null)
            statuses && statuses.forEach(item => { url_ += "statuses=" + encodeURIComponent("" + item) + "&"; });
        if (articleTypeIds !== undefined && articleTypeIds !== null)
            articleTypeIds && articleTypeIds.forEach(item => { url_ += "articleTypeIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTree(_response);
        });
    }

    protected processGetTree(response: Response): Promise<ArticleSummaryDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ArticleSummaryDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ArticleSummaryDto[]>(null as any);
    }

    get(id: string): Promise<ArticleDto> {
        let url_ = this.baseUrl + "/api/articles/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ArticleDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ArticleDto;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ArticleDto>(null as any);
    }

    delete(id: string): Promise<ArticleDeleteResponse> {
        let url_ = this.baseUrl + "/api/articles/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<ArticleDeleteResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ArticleDeleteResponse;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ArticleDeleteResponse>(null as any);
    }

    create(request: ArticleCreateRequest): Promise<ArticleSummaryDto> {
        let url_ = this.baseUrl + "/api/articles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<ArticleSummaryDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ArticleSummaryDto;
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ArticleSummaryDto>(null as any);
    }

    updateMetadata(id: string, request: ArticleUpdateMetadataRequest): Promise<void> {
        let url_ = this.baseUrl + "/api/articles/{id}/metadata";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateMetadata(_response);
        });
    }

    protected processUpdateMetadata(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateContent(id: string, request: ArticleUpdateContentRequest): Promise<VersionCaptureResponse> {
        let url_ = this.baseUrl + "/api/articles/{id}/content";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateContent(_response);
        });
    }

    protected processUpdateContent(response: Response): Promise<VersionCaptureResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as VersionCaptureResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VersionCaptureResponse>(null as any);
    }

    move(id: string, request: ArticleMoveRequest): Promise<ArticleMoveResponse> {
        let url_ = this.baseUrl + "/api/articles/{id}/move";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMove(_response);
        });
    }

    protected processMove(response: Response): Promise<ArticleMoveResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ArticleMoveResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ArticleMoveResponse>(null as any);
    }

    getVersionHistory(id: string): Promise<ArticleVersionDto[]> {
        let url_ = this.baseUrl + "/api/articles/{id}/versions";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVersionHistory(_response);
        });
    }

    protected processGetVersionHistory(response: Response): Promise<ArticleVersionDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ArticleVersionDto[];
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ArticleVersionDto[]>(null as any);
    }

    getVersion(articleId: string, versionId: string): Promise<ArticleVersionDto> {
        let url_ = this.baseUrl + "/api/articles/{articleId}/versions/{versionId}";
        if (articleId === undefined || articleId === null)
            throw new globalThis.Error("The parameter 'articleId' must be defined.");
        url_ = url_.replace("{articleId}", encodeURIComponent("" + articleId));
        if (versionId === undefined || versionId === null)
            throw new globalThis.Error("The parameter 'versionId' must be defined.");
        url_ = url_.replace("{versionId}", encodeURIComponent("" + versionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVersion(_response);
        });
    }

    protected processGetVersion(response: Response): Promise<ArticleVersionDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ArticleVersionDto;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ArticleVersionDto>(null as any);
    }

    getVersionDiff(articleId: string, versionId: string): Promise<ArticleVersionComparisonDto> {
        let url_ = this.baseUrl + "/api/articles/{articleId}/versions/{versionId}/diff";
        if (articleId === undefined || articleId === null)
            throw new globalThis.Error("The parameter 'articleId' must be defined.");
        url_ = url_.replace("{articleId}", encodeURIComponent("" + articleId));
        if (versionId === undefined || versionId === null)
            throw new globalThis.Error("The parameter 'versionId' must be defined.");
        url_ = url_.replace("{versionId}", encodeURIComponent("" + versionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVersionDiff(_response);
        });
    }

    protected processGetVersionDiff(response: Response): Promise<ArticleVersionComparisonDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ArticleVersionComparisonDto;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ArticleVersionComparisonDto>(null as any);
    }

    acceptAiVersion(articleId: string, versionId: string): Promise<VersionCaptureResponse> {
        let url_ = this.baseUrl + "/api/articles/{articleId}/versions/{versionId}/accept";
        if (articleId === undefined || articleId === null)
            throw new globalThis.Error("The parameter 'articleId' must be defined.");
        url_ = url_.replace("{articleId}", encodeURIComponent("" + articleId));
        if (versionId === undefined || versionId === null)
            throw new globalThis.Error("The parameter 'versionId' must be defined.");
        url_ = url_.replace("{versionId}", encodeURIComponent("" + versionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAcceptAiVersion(_response);
        });
    }

    protected processAcceptAiVersion(response: Response): Promise<VersionCaptureResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as VersionCaptureResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VersionCaptureResponse>(null as any);
    }

    rejectAiVersion(articleId: string, versionId: string): Promise<VersionActionResponse> {
        let url_ = this.baseUrl + "/api/articles/{articleId}/versions/{versionId}/reject";
        if (articleId === undefined || articleId === null)
            throw new globalThis.Error("The parameter 'articleId' must be defined.");
        url_ = url_.replace("{articleId}", encodeURIComponent("" + articleId));
        if (versionId === undefined || versionId === null)
            throw new globalThis.Error("The parameter 'versionId' must be defined.");
        url_ = url_.replace("{versionId}", encodeURIComponent("" + versionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRejectAiVersion(_response);
        });
    }

    protected processRejectAiVersion(response: Response): Promise<VersionActionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as VersionActionResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VersionActionResponse>(null as any);
    }
}

export class DashboardApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getMetrics(): Promise<DashboardMetrics> {
        let url_ = this.baseUrl + "/api/dashboard/metrics";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMetrics(_response);
        });
    }

    protected processGetMetrics(response: Response): Promise<DashboardMetrics> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DashboardMetrics;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DashboardMetrics>(null as any);
    }
}

export class FragmentsApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(skip?: number | undefined, take?: number | undefined): Promise<FragmentDto[]> {
        let url_ = this.baseUrl + "/api/fragments?";
        if (skip === null)
            throw new globalThis.Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new globalThis.Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<FragmentDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FragmentDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FragmentDto[]>(null as any);
    }

    get(id: string): Promise<FragmentDto> {
        let url_ = this.baseUrl + "/api/fragments/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<FragmentDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FragmentDto;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FragmentDto>(null as any);
    }

    deleteFragment(id: string): Promise<DeleteFragmentResponse> {
        let url_ = this.baseUrl + "/api/fragments/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteFragment(_response);
        });
    }

    protected processDeleteFragment(response: Response): Promise<DeleteFragmentResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeleteFragmentResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeleteFragmentResponse>(null as any);
    }

    getBySourceId(sourceId: string): Promise<FragmentDto[]> {
        let url_ = this.baseUrl + "/api/fragments/by-source/{sourceId}";
        if (sourceId === undefined || sourceId === null)
            throw new globalThis.Error("The parameter 'sourceId' must be defined.");
        url_ = url_.replace("{sourceId}", encodeURIComponent("" + sourceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBySourceId(_response);
        });
    }

    protected processGetBySourceId(response: Response): Promise<FragmentDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FragmentDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FragmentDto[]>(null as any);
    }

    getByArticleId(articleId: string): Promise<FragmentDto[]> {
        let url_ = this.baseUrl + "/api/fragments/by-article/{articleId}";
        if (articleId === undefined || articleId === null)
            throw new globalThis.Error("The parameter 'articleId' must be defined.");
        url_ = url_.replace("{articleId}", encodeURIComponent("" + articleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetByArticleId(_response);
        });
    }

    protected processGetByArticleId(response: Response): Promise<FragmentDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FragmentDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FragmentDto[]>(null as any);
    }

    search(query?: string | undefined, take?: number | undefined): Promise<FragmentSearchResult[]> {
        let url_ = this.baseUrl + "/api/fragments/search?";
        if (query === null)
            throw new globalThis.Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (take === null)
            throw new globalThis.Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<FragmentSearchResult[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FragmentSearchResult[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FragmentSearchResult[]>(null as any);
    }

    getTitles(ids: string[]): Promise<FragmentTitleDto[]> {
        let url_ = this.baseUrl + "/api/fragments/titles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTitles(_response);
        });
    }

    protected processGetTitles(response: Response): Promise<FragmentTitleDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FragmentTitleDto[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FragmentTitleDto[]>(null as any);
    }

    updateConfidence(id: string, request: UpdateFragmentConfidenceRequest): Promise<FragmentDto> {
        let url_ = this.baseUrl + "/api/fragments/{id}/confidence";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateConfidence(_response);
        });
    }

    protected processUpdateConfidence(response: Response): Promise<FragmentDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FragmentDto;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FragmentDto>(null as any);
    }
}

export class PlanApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getAllPlans(articleId: string): Promise<PlanSummaryDto[]> {
        let url_ = this.baseUrl + "/api/articles/{articleId}/plans";
        if (articleId === undefined || articleId === null)
            throw new globalThis.Error("The parameter 'articleId' must be defined.");
        url_ = url_.replace("{articleId}", encodeURIComponent("" + articleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllPlans(_response);
        });
    }

    protected processGetAllPlans(response: Response): Promise<PlanSummaryDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PlanSummaryDto[];
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PlanSummaryDto[]>(null as any);
    }

    getPlan(articleId: string, planId: string): Promise<PlanDto> {
        let url_ = this.baseUrl + "/api/articles/{articleId}/plans/{planId}";
        if (articleId === undefined || articleId === null)
            throw new globalThis.Error("The parameter 'articleId' must be defined.");
        url_ = url_.replace("{articleId}", encodeURIComponent("" + articleId));
        if (planId === undefined || planId === null)
            throw new globalThis.Error("The parameter 'planId' must be defined.");
        url_ = url_.replace("{planId}", encodeURIComponent("" + planId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPlan(_response);
        });
    }

    protected processGetPlan(response: Response): Promise<PlanDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PlanDto;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PlanDto>(null as any);
    }

    updatePlan(articleId: string, planId: string, request: UpdatePlanRequest): Promise<PlanActionResponse> {
        let url_ = this.baseUrl + "/api/articles/{articleId}/plans/{planId}";
        if (articleId === undefined || articleId === null)
            throw new globalThis.Error("The parameter 'articleId' must be defined.");
        url_ = url_.replace("{articleId}", encodeURIComponent("" + articleId));
        if (planId === undefined || planId === null)
            throw new globalThis.Error("The parameter 'planId' must be defined.");
        url_ = url_.replace("{planId}", encodeURIComponent("" + planId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdatePlan(_response);
        });
    }

    protected processUpdatePlan(response: Response): Promise<PlanActionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PlanActionResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PlanActionResponse>(null as any);
    }

    restorePlan(articleId: string, planId: string): Promise<PlanActionResponse> {
        let url_ = this.baseUrl + "/api/articles/{articleId}/plans/{planId}/restore";
        if (articleId === undefined || articleId === null)
            throw new globalThis.Error("The parameter 'articleId' must be defined.");
        url_ = url_.replace("{articleId}", encodeURIComponent("" + articleId));
        if (planId === undefined || planId === null)
            throw new globalThis.Error("The parameter 'planId' must be defined.");
        url_ = url_.replace("{planId}", encodeURIComponent("" + planId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRestorePlan(_response);
        });
    }

    protected processRestorePlan(response: Response): Promise<PlanActionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PlanActionResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PlanActionResponse>(null as any);
    }

    updatePlanFragmentInclude(articleId: string, planId: string, fragmentId: string, request: UpdatePlanFragmentIncludeRequest): Promise<PlanActionResponse> {
        let url_ = this.baseUrl + "/api/articles/{articleId}/plans/{planId}/fragments/{fragmentId}/include";
        if (articleId === undefined || articleId === null)
            throw new globalThis.Error("The parameter 'articleId' must be defined.");
        url_ = url_.replace("{articleId}", encodeURIComponent("" + articleId));
        if (planId === undefined || planId === null)
            throw new globalThis.Error("The parameter 'planId' must be defined.");
        url_ = url_.replace("{planId}", encodeURIComponent("" + planId));
        if (fragmentId === undefined || fragmentId === null)
            throw new globalThis.Error("The parameter 'fragmentId' must be defined.");
        url_ = url_.replace("{fragmentId}", encodeURIComponent("" + fragmentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdatePlanFragmentInclude(_response);
        });
    }

    protected processUpdatePlanFragmentInclude(response: Response): Promise<PlanActionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PlanActionResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PlanActionResponse>(null as any);
    }

    updatePlanFragmentInstructions(articleId: string, planId: string, fragmentId: string, request: UpdatePlanFragmentInstructionsRequest): Promise<PlanActionResponse> {
        let url_ = this.baseUrl + "/api/articles/{articleId}/plans/{planId}/fragments/{fragmentId}/instructions";
        if (articleId === undefined || articleId === null)
            throw new globalThis.Error("The parameter 'articleId' must be defined.");
        url_ = url_.replace("{articleId}", encodeURIComponent("" + articleId));
        if (planId === undefined || planId === null)
            throw new globalThis.Error("The parameter 'planId' must be defined.");
        url_ = url_.replace("{planId}", encodeURIComponent("" + planId));
        if (fragmentId === undefined || fragmentId === null)
            throw new globalThis.Error("The parameter 'fragmentId' must be defined.");
        url_ = url_.replace("{fragmentId}", encodeURIComponent("" + fragmentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdatePlanFragmentInstructions(_response);
        });
    }

    protected processUpdatePlanFragmentInstructions(response: Response): Promise<PlanActionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PlanActionResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PlanActionResponse>(null as any);
    }

    acceptPlan(articleId: string, planId: string): Promise<PlanActionResponse> {
        let url_ = this.baseUrl + "/api/articles/{articleId}/plans/{planId}/accept";
        if (articleId === undefined || articleId === null)
            throw new globalThis.Error("The parameter 'articleId' must be defined.");
        url_ = url_.replace("{articleId}", encodeURIComponent("" + articleId));
        if (planId === undefined || planId === null)
            throw new globalThis.Error("The parameter 'planId' must be defined.");
        url_ = url_.replace("{planId}", encodeURIComponent("" + planId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAcceptPlan(_response);
        });
    }

    protected processAcceptPlan(response: Response): Promise<PlanActionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PlanActionResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PlanActionResponse>(null as any);
    }

    rejectPlan(articleId: string, planId: string): Promise<PlanActionResponse> {
        let url_ = this.baseUrl + "/api/articles/{articleId}/plans/{planId}/reject";
        if (articleId === undefined || articleId === null)
            throw new globalThis.Error("The parameter 'articleId' must be defined.");
        url_ = url_.replace("{articleId}", encodeURIComponent("" + articleId));
        if (planId === undefined || planId === null)
            throw new globalThis.Error("The parameter 'planId' must be defined.");
        url_ = url_.replace("{planId}", encodeURIComponent("" + planId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRejectPlan(_response);
        });
    }

    protected processRejectPlan(response: Response): Promise<PlanActionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PlanActionResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PlanActionResponse>(null as any);
    }
}

export class SourcesApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(query?: string | null | undefined, tagTypeId?: string | null | undefined, value?: string | null | undefined, skip?: number | undefined, take?: number | undefined): Promise<SourceSummaryDto[]> {
        let url_ = this.baseUrl + "/api/sources?";
        if (query !== undefined && query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (tagTypeId !== undefined && tagTypeId !== null)
            url_ += "tagTypeId=" + encodeURIComponent("" + tagTypeId) + "&";
        if (value !== undefined && value !== null)
            url_ += "value=" + encodeURIComponent("" + value) + "&";
        if (skip === null)
            throw new globalThis.Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new globalThis.Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<SourceSummaryDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SourceSummaryDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SourceSummaryDto[]>(null as any);
    }

    get(id: string): Promise<SourceDto> {
        let url_ = this.baseUrl + "/api/sources/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<SourceDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SourceDto;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SourceDto>(null as any);
    }

    deleteSource(id: string): Promise<DeleteSourceResponse> {
        let url_ = this.baseUrl + "/api/sources/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSource(_response);
        });
    }

    protected processDeleteSource(response: Response): Promise<DeleteSourceResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeleteSourceResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeleteSourceResponse>(null as any);
    }

    extractFragments(id: string): Promise<FragmentExtractionResponse> {
        let url_ = this.baseUrl + "/api/sources/{id}/extract-fragments";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExtractFragments(_response);
        });
    }

    protected processExtractFragments(response: Response): Promise<FragmentExtractionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FragmentExtractionResponse;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FragmentExtractionResponse>(null as any);
    }

    tagSource(id: string, force?: boolean | undefined): Promise<TaggingResponse> {
        let url_ = this.baseUrl + "/api/sources/{id}/tag?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (force === null)
            throw new globalThis.Error("The parameter 'force' cannot be null.");
        else if (force !== undefined)
            url_ += "force=" + encodeURIComponent("" + force) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTagSource(_response);
        });
    }

    protected processTagSource(response: Response): Promise<TaggingResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TaggingResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaggingResponse>(null as any);
    }
}

export class SpeakersApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(isInternal?: boolean | null | undefined, search?: string | null | undefined): Promise<SpeakerListDto[]> {
        let url_ = this.baseUrl + "/api/speakers?";
        if (isInternal !== undefined && isInternal !== null)
            url_ += "isInternal=" + encodeURIComponent("" + isInternal) + "&";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<SpeakerListDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SpeakerListDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SpeakerListDto[]>(null as any);
    }

    getById(id: string): Promise<SpeakerDetailDto> {
        let url_ = this.baseUrl + "/api/speakers/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: Response): Promise<SpeakerDetailDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SpeakerDetailDto;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SpeakerDetailDto>(null as any);
    }

    update(id: string, request: UpdateSpeakerRequest): Promise<SpeakerDetailDto> {
        let url_ = this.baseUrl + "/api/speakers/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<SpeakerDetailDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SpeakerDetailDto;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SpeakerDetailDto>(null as any);
    }
}

export class TagTypesApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(): Promise<TagTypeDto[]> {
        let url_ = this.baseUrl + "/api/tagtypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<TagTypeDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TagTypeDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TagTypeDto[]>(null as any);
    }
}

export interface AiPromptListDto {
    id?: string | null;
    name?: string;
    type?: PromptType;
    description?: string | null;
    isPerArticleType?: boolean;
    articleTypeId?: string | null;
    articleTypeName?: string | null;
    isPerFragmentCategory?: boolean;
    fragmentCategoryId?: string | null;
    fragmentCategoryName?: string | null;
    exists?: boolean;
    createdAt?: Date | null;
    lastModifiedAt?: Date | null;
}

export enum PromptType {
    FragmentExtraction = "FragmentExtraction",
    OrganizationContext = "OrganizationContext",
    ConfidenceScoring = "ConfidenceScoring",
    ArticlePlanCreation = "ArticlePlanCreation",
    ArticleAgentMode = "ArticleAgentMode",
    ArticlePlanImplementation = "ArticlePlanImplementation",
    ArticleTypePlanMode = "ArticleTypePlanMode",
    ArticleTypeAgentMode = "ArticleTypeAgentMode",
    FragmentCategoryExtraction = "FragmentCategoryExtraction",
    CursorReview = "CursorReview",
    CursorQuestion = "CursorQuestion",
}

export interface AiPromptDto {
    id?: string | null;
    name?: string;
    type?: PromptType;
    description?: string | null;
    isPerArticleType?: boolean;
    articleTypeId?: string | null;
    articleTypeName?: string | null;
    isPerFragmentCategory?: boolean;
    fragmentCategoryId?: string | null;
    fragmentCategoryName?: string | null;
    content?: string;
    exists?: boolean;
    createdAt?: Date | null;
    lastModifiedAt?: Date | null;
}

export interface ProblemDetails {
    type?: string | null;
    title?: string | null;
    status?: number | null;
    detail?: string | null;
    instance?: string | null;

    [key: string]: any;
}

export interface CreateOrUpdateAiPromptRequest {
    content?: string;
}

export interface ArticleTypeDto {
    id?: string;
    name?: string;
    icon?: string | null;
}

export interface FragmentCategoryDto {
    id?: string;
    name?: string;
    icon?: string | null;
}

export interface ConversationDto {
    id?: string;
    state?: string;
    mode?: string;
    isRunning?: boolean;
    createdAt?: Date;
    createdBy?: string;
    implementingPlanId?: string | null;
    implementingPlanVersion?: number | null;
}

export enum ConversationMode {
    Agent = "Agent",
    Plan = "Plan",
}

export interface ChatMessageDto {
    id?: string;
    conversationId?: string;
    role?: ChatMessageRole;
    text?: string | null;
    userName?: string | null;
    createdAt?: Date;
    toolCalls?: ToolCallDto[];
}

export enum ChatMessageRole {
    User = "User",
    Assistant = "Assistant",
    System = "System",
    Tool = "Tool",
}

export interface ToolCallDto {
    callId?: string;
    name?: string;
    display?: string | null;
    completed?: boolean;
    isError?: boolean;
    result?: ToolCallResultDto | null;
}

export interface ToolCallResultDto {
    ids?: string[];
}

export interface ToolResultContentResponse {
    toolCallId?: string;
    toolName?: string;
    content?: string;
    question?: string | null;
}

export interface SendMessageResponse {
    messageId?: string;
    conversationId?: string;
}

export interface SendMessageRequest {
    message?: string;
    mode?: ConversationMode | null;
}

export interface ConversationStatusResponse {
    id?: string;
    state?: ConversationState;
    timestamp?: Date;
}

export enum ConversationState {
    Active = "Active",
    Complete = "Complete",
    Archived = "Archived",
}

export interface ArticleSummaryDto {
    id?: string;
    title?: string;
    status?: ArticleStatus;
    parentArticleId?: string | null;
    articleTypeId?: string | null;
    assignedUser?: UserSummaryDto | null;
    children?: ArticleSummaryDto[];
    currentConversation?: ConversationSummaryDto | null;
    createdAt?: Date;
    modifiedAt?: Date | null;
}

export enum ArticleStatus {
    Draft = "Draft",
    Review = "Review",
    Approved = "Approved",
    Archived = "Archived",
}

export interface UserSummaryDto {
    id?: string;
    fullName?: string;
    initials?: string | null;
    color?: string | null;
}

export interface ConversationSummaryDto {
    id?: string;
    isRunning?: boolean;
    state?: ConversationState;
}

export interface ArticleDto {
    id?: string;
    title?: string;
    content?: string | null;
    status?: ArticleStatus;
    parentArticleId?: string | null;
    currentConversation?: ConversationSummaryDto | null;
    currentPlan?: PlanRef | null;
    createdAt?: Date;
}

export interface PlanRef {
    id?: string;
    status?: PlanStatus;
}

export enum PlanStatus {
    Draft = "Draft",
    InProgress = "InProgress",
    Applied = "Applied",
    Archived = "Archived",
}

export interface ArticleCreateRequest {
    title: string;
    parentArticleId?: string | null;
    articleTypeId?: string | null;
}

export interface ArticleUpdateMetadataRequest {
    title: string;
    status?: ArticleStatus | null;
    articleTypeId?: string | null;
}

export interface VersionCaptureResponse {
    isNewVersion?: boolean;
    versionId?: string;
    versionNumber?: string;
}

export interface ArticleUpdateContentRequest {
    content: string;
}

export interface ArticleDeleteResponse {
    message?: string;
}

export interface ArticleMoveResponse {
    message?: string;
    articleId?: string;
    oldParentId?: string | null;
    newParentId?: string;
}

export interface ArticleMoveRequest {
    newParentArticleId?: string | null;
}

export interface ArticleVersionDto {
    id?: string;
    articleId?: string;
    conversationId?: string | null;
    versionNumber?: string;
    createdBy?: UserRef | null;
    createdAt?: Date;
    modifiedAt?: Date | null;
    versionType?: VersionType;
    parentVersionId?: string | null;
    changeMessage?: string | null;
    reviewAction?: ReviewAction;
    reviewedAt?: Date | null;
    reviewedBy?: UserRef | null;
    status?: VersionStatus | null;
}

export interface UserRef {
    id?: string;
    fullName?: string;
}

export enum VersionType {
    User = "User",
    AI = "AI",
}

export enum ReviewAction {
    None = "None",
    Accepted = "Accepted",
    Rejected = "Rejected",
}

export enum VersionStatus {
    CurrentVersion = "CurrentVersion",
    OldVersion = "OldVersion",
    PendingAiVersion = "PendingAiVersion",
    AcceptedAiVersion = "AcceptedAiVersion",
    RejectedAiVersion = "RejectedAiVersion",
    OldAiVersion = "OldAiVersion",
}

export interface ArticleVersionComparisonDto {
    versionId?: string;
    versionNumber?: string;
    beforeContent?: string;
    afterContent?: string;
}

export interface VersionActionResponse {
    success?: boolean;
    message?: string;
}

export interface DashboardMetrics {
    totalSources?: number;
    sourcesByType?: MetricItem[];
    sourcesByIntegration?: MetricItem[];
    sourcesByYear?: StackedMetricItem[];
    sourcesByMonth?: MetricItem[];
    sourcesByTagType?: TagTypeMetrics[];
    sourcesPendingSmartTagging?: number;
    sourcesPendingFragmentGeneration?: number;
    totalFragments?: number;
    fragmentsByCategory?: MetricItem[];
    fragmentsPendingEmbedding?: number;
    totalArticles?: number;
    articlesByType?: MetricItem[];
}

export interface MetricItem {
    label?: string;
    count?: number;
    icon?: string | null;
}

export interface StackedMetricItem {
    label?: string;
    values?: { [key: string]: number; };
}

export interface TagTypeMetrics {
    tagTypeName?: string;
    tagCounts?: MetricItem[];
}

export interface FragmentDto {
    id?: string;
    title?: string;
    summary?: string;
    category?: string;
    categoryIcon?: string | null;
    content?: string;
    sourceId?: string | null;
    sourceName?: string | null;
    sourceType?: SourceType | null;
    sourceDate?: Date | null;
    createdAt?: Date;
    lastModifiedAt?: Date | null;
    confidence?: ConfidenceLevel | null;
    confidenceComment?: string | null;
}

export enum SourceType {
    Unknown = "Unknown",
    Meeting = "Meeting",
}

export enum ConfidenceLevel {
    Unclear = "Unclear",
    Low = "Low",
    Medium = "Medium",
    High = "High",
    Certain = "Certain",
}

export interface FragmentSearchResult {
    id?: string;
    title?: string;
    summary?: string;
    category?: string;
    categoryIcon?: string | null;
    sourceId?: string | null;
    sourceName?: string | null;
    sourceType?: SourceType | null;
    sourceDate?: Date | null;
    createdAt?: Date;
    confidence?: ConfidenceLevel | null;
    confidenceComment?: string | null;
    similarity?: number;
}

export interface FragmentTitleDto {
    id?: string;
    title?: string;
}

export interface UpdateFragmentConfidenceRequest {
    confidence?: ConfidenceLevel | null;
    confidenceComment?: string | null;
}

export interface DeleteFragmentResponse {
    success?: boolean;
    message?: string | null;
}

export interface PlanSummaryDto {
    id?: string;
    version?: number;
    status?: PlanStatus;
    createdAt?: Date;
    changesSummary?: string | null;
    createdBy?: UserRef;
}

export interface PlanDto {
    id?: string;
    articleId?: string;
    instructions?: string;
    status?: PlanStatus;
    version?: number;
    changesSummary?: string | null;
    createdAt?: Date;
    createdBy?: UserRef;
    fragments?: PlanFragmentDto[];
}

export interface PlanFragmentDto {
    id?: string;
    fragmentId?: string;
    similarityScore?: number;
    include?: boolean;
    reasoning?: string | null;
    instructions?: string | null;
    fragment?: FragmentInPlanDto;
}

export interface FragmentInPlanDto {
    id?: string;
    title?: string;
    summary?: string;
    category?: string;
    categoryIcon?: string | null;
    content?: string;
    confidence?: string | null;
    confidenceComment?: string | null;
    source?: SourceInPlanDto | null;
}

export interface SourceInPlanDto {
    id?: string;
    name?: string;
    type?: string;
    date?: Date;
}

export interface PlanActionResponse {
    success?: boolean;
    message?: string | null;
    conversationId?: string;
}

export interface UpdatePlanRequest {
    instructions?: string;
}

export interface UpdatePlanFragmentIncludeRequest {
    include?: boolean;
}

export interface UpdatePlanFragmentInstructionsRequest {
    instructions?: string;
}

export interface SourceSummaryDto {
    id?: string;
    name?: string;
    type?: SourceType;
    date?: Date;
    integrationName?: string;
    fragmentsCount?: number;
    extractionStatus?: ExtractionStatus;
    primarySpeakerName?: string | null;
    primarySpeakerTrustLevel?: TrustLevel | null;
}

export enum ExtractionStatus {
    NotStarted = "NotStarted",
    InProgress = "InProgress",
    Completed = "Completed",
    Failed = "Failed",
}

export enum TrustLevel {
    High = "High",
    Medium = "Medium",
    Low = "Low",
}

export interface SourceDto {
    id?: string;
    type?: SourceType;
    metadataType?: SourceMetadataType;
    name?: string;
    externalId?: string | null;
    content?: string | null;
    speechSegments?: SpeechSegmentDto[] | null;
    speakers?: SpeakerDto[] | null;
    metadataJson?: string;
    date?: Date;
    isInternal?: boolean | null;
    tagsGenerated?: Date | null;
    primarySpeakerName?: string | null;
    primarySpeakerTrustLevel?: TrustLevel | null;
    extractionStatus?: ExtractionStatus;
    extractionMessage?: string | null;
    integrationName?: string;
    fragmentsCount?: number;
    createdAt?: Date;
    tags?: SourceTagDto[];
}

export enum SourceMetadataType {
    Unknown = "Unknown",
    Collector_GoogleDrive = "Collector_GoogleDrive",
    Collector_Fellow = "Collector_Fellow",
}

export interface SpeechSegmentDto {
    speakerId?: string | null;
    speakerName?: string;
    text?: string;
}

export interface SpeakerDto {
    id?: string;
    name?: string;
    email?: string | null;
    isInternal?: boolean | null;
    trustLevel?: string | null;
}

export interface SourceTagDto {
    tagTypeId?: string;
    tagType?: string;
    value?: string;
    allowedValue?: string | null;
}

export interface FragmentExtractionResponse {
    success?: boolean;
    jobId?: string | null;
    message?: string;
}

export interface TaggingResponse {
    success?: boolean;
    skipped?: boolean;
    message?: string;
    isInternal?: boolean | null;
    tagCount?: number;
}

export interface DeleteSourceResponse {
    success?: boolean;
    message?: string | null;
}

export interface SpeakerListDto {
    id?: string;
    name?: string;
    email?: string | null;
    isInternal?: boolean | null;
    trustLevel?: TrustLevel | null;
    sourceCount?: number;
    createdAt?: Date;
}

export interface SpeakerDetailDto {
    id?: string;
    name?: string;
    email?: string | null;
    isInternal?: boolean | null;
    trustLevel?: TrustLevel | null;
    sourceCount?: number;
    createdAt?: Date;
}

export interface UpdateSpeakerRequest {
    isInternal?: boolean | null;
    trustLevel?: TrustLevel | null;
}

export interface TagTypeDto {
    id?: string;
    name?: string;
    prompt?: string | null;
    isConstrained?: boolean;
    scopeUpdateMode?: ScopeUpdateMode;
    allowedValues?: string[];
}

export enum ScopeUpdateMode {
    None = "None",
    MarkInternalIfUnknown = "MarkInternalIfUnknown",
    MarkExternalIfUnknown = "MarkExternalIfUnknown",
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    throw new ApiException(message, status, response, headers, result);
}