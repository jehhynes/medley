@{
    ViewData["Title"] = "Sources";
    ViewData["HasRightSidebar"] = false;
    ViewData["HasLeftSidebar"] = true;
    Layout = "_VueLayout";
}

@section Styles {
    <style>
        json-viewer {
            --background-color: transparent;
        }
  
        
        
        
        /* Make main content use flexbox for independent tab scrolling */
        .main-content {
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
            padding: 0;
        }
        
        .main-content-header {
            flex-shrink: 0;
            padding: 2rem 2.5rem 0 2.5rem;
            margin-bottom: 0;
        }
        
        /* Tab navigation container */
        .main-content .nav-tabs {
            flex-shrink: 0;
            margin: 0 2.5rem;
            padding-top: 1rem;
            border-bottom: 1px solid var(--bs-border-color);
        }
        
        /* Tab content container - takes remaining space and scrolls */
        .main-content .tab-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0; /* Important for flex children to respect overflow */
        }
        
        /* Each tab pane should fill available space and scroll independently */
        .main-content .tab-pane {
            height: 100%;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 1.5rem 2.5rem 2rem 2.5rem;
            min-height: 0; /* Important for flex children to respect overflow */
        }
        
        /* Content preview - let it flow naturally within scrolling tab pane */
        .content-preview {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        /* Empty state should be centered */
        .main-content .empty-state {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding: 2rem 2.5rem;
        }
        
        /* Fragment list styles */
        .fragment-list {
            width: 100%;
        }
        
        .fragment-list .fragment-item:hover {
            background-color: var(--bs-secondary-bg);
        }
    </style>
}

<!-- Left Sidebar (List) -->
<div class="sidebar left-sidebar">
    <div class="sidebar-header">
        <h6 class="sidebar-title">Sources</h6>
        <div class="input-group input-group-sm">
            <input type="text" class="form-control" placeholder="Search..." v-model="searchQuery" @@input="onSearchInput">
        </div>
    </div>
    <div class="sidebar-content">
        <div v-if="loading" class="loading-spinner">
            <div class="spinner-border spinner-border-sm" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
        </div>
        <div v-else-if="error" class="alert alert-danger" v-cloak>
            {{ error }}
        </div>
        <source-list 
            v-else
            :sources="sources"
            :selected-id="selectedSourceId"
            :extraction-status="extractionStatus"
            @@select="selectSource"
        />
        <div v-if="!loading && sources.length === 0" class="empty-state">
            <div class="empty-state-icon">
                <i class="bi bi-camera-video"></i>
            </div>
            <div class="empty-state-title">No Sources Found</div>
            <div class="empty-state-text">Connect an integration to import sources</div>
        </div>
    </div>
</div>

<!-- Main Content -->
<div class="main-content">
    <div v-if="!selectedSource" class="empty-state">
        <div class="empty-state-icon">
            <i class="bi bi-camera-video"></i>
        </div>
        <div class="empty-state-title">No Source Selected</div>
        <div class="empty-state-text">Select a source from the sidebar to view its details</div>
    </div>
    <div v-else class="d-flex flex-column h-100">
        <div class="main-content-header">
            <div class="d-flex justify-content-between align-items-start mb-3">
                <div>
                    <h1 class="main-content-title">{{ selectedSource.name || 'Untitled Source' }}</h1>
                    <div class="text-muted">
                        <span class="badge bg-primary">{{ selectedSource.type }}</span>
                        <span class="ms-2">
                            <i class="bi bi-calendar3"></i>
                            {{ formatDate(selectedSource.date) }}
                        </span>
                        <span class="ms-2">
                            <i class="bi bi-plug"></i>
                            {{ selectedSource.integrationName }}
                        </span>
                        <span class="ms-2" v-if="selectedSource.fragmentsCount !== undefined">
                            <i class="bi bi-puzzle"></i>
                            {{ selectedSource.fragmentsCount }} fragments
                        </span>
                    </div>
                </div>
                <div>
                    <button 
                        class="btn btn-primary" 
                        @@click="extractFragments" 
                        :disabled="extractionStatus[selectedSource.id] === 'extracting'"
                        v-if="selectedSource.content">
                        <i class="bi bi-magic"></i> Extract Fragments
                    </button>
                </div>
            </div>
        </div>

        <ul class="nav nav-tabs" role="tablist">
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="content-tab" data-bs-toggle="tab" data-bs-target="#content-pane" type="button" role="tab" aria-controls="content-pane" aria-selected="true">
                    Content
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="fragments-tab" data-bs-toggle="tab" data-bs-target="#fragments-pane" type="button" role="tab" aria-controls="fragments-pane" aria-selected="false">
                    Fragments
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="metadata-tab" data-bs-toggle="tab" data-bs-target="#metadata-pane" type="button" role="tab" aria-controls="metadata-pane" aria-selected="false">
                    Metadata
                </button>
            </li>
        </ul>

        <div class="tab-content">
            <div class="tab-pane show active" id="content-pane" role="tabpanel" aria-labelledby="content-tab">
                <div v-if="selectedSource.content">
                    <div class="content-preview">
                        {{ selectedSource.content }}
                    </div>
                </div>
                <div v-else class="text-muted">
                    No content available
                </div>
            </div>
            <div class="tab-pane" id="fragments-pane" role="tabpanel" aria-labelledby="fragments-tab">
                <div v-if="loadingFragments" class="text-center py-4">
                    <div class="spinner-border spinner-border-sm" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                </div>
                <div v-else-if="fragmentsError" class="alert alert-danger" v-cloak>
                    {{ fragmentsError }}
                </div>
                <div v-else-if="selectedFragment">
                    <div class="mb-3">
                        <button class="btn btn-sm btn-outline-secondary" @@click="selectedFragment = null">
                            <i class="bi bi-arrow-left"></i> Back to List
                        </button>
                    </div>
                    <div class="fragment-content">
                        <div v-if="selectedFragment.title" class="mb-3">
                            <h3>{{ selectedFragment.title }}</h3>
                        </div>
                        <div v-if="selectedFragment.category" class="mb-2">
                            <span class="badge bg-secondary">{{ selectedFragment.category }}</span>
                        </div>
                        @* <div v-if="selectedFragment.summary" class="mb-3 text-muted">
                            {{ selectedFragment.summary }}
                        </div> *@
                        <div class="markdown-content" v-html="renderedMarkdown"></div>
                    </div>
                </div>
                <div v-else-if="fragments.length === 0" class="text-muted">
                    No fragments available. Click "Extract Fragments" to generate fragments from this source.
                </div>
                <div v-else class="fragment-list">
                    <table class="table table-hover">
                        <tbody>
                            <tr 
                                v-for="fragment in fragments" 
                                :key="fragment.id"
                                class="fragment-item"
                                @@click="selectFragment(fragment)"
                                style="cursor: pointer;"
                            >
                                <td class="align-middle" style="width: 50px;">
                                    <i 
                                        :class="getIconClass(getFragmentCategoryIcon(fragment.category))" 
                                        :title="fragment.category || ''"
                                        style="font-size: 1.25rem;"
                                    ></i>
                                </td>
                                <td>
                                    <div class="fw-semibold">{{ fragment.title || 'Untitled Fragment' }}</div>
                                    <div v-if="fragment.summary" class="text-muted small">
                                        {{ fragment.summary }}
                                    </div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div class="tab-pane" id="metadata-pane" role="tabpanel" aria-labelledby="metadata-tab">
                <div v-if="parsedMetadata">
                    <json-viewer ref="jsonViewer"></json-viewer>
                </div>
                <div v-else class="text-muted">
                    No metadata available
                </div>
            </div>
        </div>
    </div>
</div>

@section VueTemplates {
    @* Vue Component Templates - outside #app so they don't get destroyed *@
    @await Html.PartialAsync("Templates/_SourceListTemplate")
}

@section Scripts {
    <script src="https://cdn.jsdelivr.net/npm/marked@12.0.0/marked.min.js"></script>
    <script src="~/js/app.js"></script>
    <script src="~/js/utils.js"></script>
    <script src="~/js/components/source-list.js"></script>
    <script>
        (function() {
            const { createApp } = Vue;
            const { api, createSignalRConnection } = window.ArticleBrowserApp;
            const { formatDate, copyToClipboard } = window.MedleyUtils;

            // Single unified Vue app for the entire Sources page
            const app = createApp({
                components: {
                    'source-list': SourceList
                },
                data() {
                    return {
                        sources: [],
                        selectedSourceId: null,
                        selectedSource: null,
                        loading: false,
                        error: null,
                        searchQuery: '',
                        extractionStatus: {}, // Maps sourceId -> 'not-started' | 'extracting' | 'completed'
                        signalRConnection: null,
                        fragments: [],
                        selectedFragment: null,
                        loadingFragments: false,
                        fragmentsError: null,
                        markdownRenderer: null,
                        articleTypes: [] // Array of { id, name, icon }
                    };
                },
                computed: {
                    parsedMetadata() {
                        if (!this.selectedSource || !this.selectedSource.metadataJson) {
                            return null;
                        }
                        try {
                            return JSON.parse(this.selectedSource.metadataJson);
                        } catch (e) {
                            console.error('Failed to parse metadata JSON:', e);
                            return null;
                        }
                    },
                    renderedMarkdown() {
                        if (!this.selectedFragment || !this.selectedFragment.content || !this.markdownRenderer) {
                            return '';
                        }
                        try {
                            return this.markdownRenderer.parse(this.selectedFragment.content, { breaks: true, gfm: true });
                        } catch (e) {
                            console.error('Failed to render markdown:', e);
                            return this.selectedFragment.content;
                        }
                    }
                },
                watch: {
                    parsedMetadata(newVal) {
                        this.$nextTick(() => {
                            if (this.$refs.jsonViewer && newVal) {
                                this.$refs.jsonViewer.data = newVal;
                            }
                        });
                    },
                    selectedSource(newVal) {
                        // Reset fragments when source changes
                        this.fragments = [];
                        this.selectedFragment = null;
                        this.fragmentsError = null;
                        
                        // Load fragments if source is selected
                        if (newVal) {
                            this.loadFragments();
                        }
                    }
                },
                methods: {
                    // Maps ExtractionStatus enum value to component status string
                    mapExtractionStatus(extractionStatus) {
                        if (extractionStatus === undefined || extractionStatus === null) {
                            return 'not-started';
                        }
                        // Handle both enum values (0, 1, 2, 3) and string values
                        const statusMap = {
                            0: 'not-started', // NotStarted
                            1: 'extracting',  // InProgress
                            2: 'completed',  // Completed
                            3: 'failed',     // Failed
                            'NotStarted': 'not-started',
                            'InProgress': 'extracting',
                            'Completed': 'completed',
                            'Failed': 'failed'
                        };
                        return statusMap[extractionStatus] || 'not-started';
                    },
                    
                    async loadSources() {
                        this.loading = true;
                        this.error = null;
                        try {
                            this.sources = await api.get('/api/sources');
                            // Initialize extraction status for all sources from API response
                            this.sources.forEach(source => {
                                this.extractionStatus[source.id] = this.mapExtractionStatus(source.extractionStatus);
                            });
                        } catch (err) {
                            this.error = 'Failed to load sources: ' + err.message;
                            console.error('Error loading sources:', err);
                        } finally {
                            this.loading = false;
                        }
                    },
                    
                    async selectSource(source, replaceState = false) {
                        this.selectedSourceId = source.id;
                        
                        // Update URL with selected source ID
                        const url = new URL(window.location);
                        const currentId = url.searchParams.get('id');
                        if (currentId !== source.id) {
                            url.searchParams.set('id', source.id);
                            if (replaceState) {
                                window.history.replaceState({}, '', url);
                            } else {
                                window.history.pushState({}, '', url);
                            }
                        }
                        
                        try {
                            this.selectedSource = await api.get(`/api/sources/${source.id}`);
                            // Update extraction status from API response
                            this.extractionStatus[source.id] = this.mapExtractionStatus(this.selectedSource.extractionStatus);
                        } catch (err) {
                            console.error('Error loading source:', err);
                            this.selectedSource = null;
                        }
                    },
                    
                    async onSearchInput() {
                        const query = this.searchQuery.trim();
                        if (query.length >= 2) {
                            try {
                                this.sources = await api.get(`/api/sources/search?query=${encodeURIComponent(query)}`);
                                // Map extraction status for search results
                                this.sources.forEach(source => {
                                    this.extractionStatus[source.id] = this.mapExtractionStatus(source.extractionStatus);
                                });
                            } catch (err) {
                                console.error('Search error:', err);
                            }
                        } else if (query.length === 0) {
                            await this.loadSources();
                        }
                    },
                    
                    async extractFragments() {
                        if (!this.selectedSource) return;
                        
                        const sourceId = this.selectedSource.id;
                        this.extractionStatus[sourceId] = 'extracting';
                        try {
                            const response = await api.post(`/api/sources/${sourceId}/extract-fragments`);
                            
                            if (response.success) {
                                // Show success toast
                                this.showToast('success', response.message || 'Fragment extraction started successfully');
                                // Keep button disabled until SignalR notification arrives
                            } else {
                                this.showToast('error', response.message || 'Failed to start fragment extraction');
                                this.extractionStatus[sourceId] = 'not-started';
                            }
                        } catch (err) {
                            console.error('Fragment extraction error:', err);
                            this.showToast('error', err.message || 'Failed to extract fragments. Please try again.');
                            this.extractionStatus[sourceId] = 'not-started';
                        }
                    },
                    
                    showToast(type, message) {
                        // Simple toast notification using Bootstrap toast
                        const toastContainer = document.getElementById('toast-container');
                        if (!toastContainer) {
                            const container = document.createElement('div');
                            container.id = 'toast-container';
                            container.className = 'toast-container position-fixed top-0 end-0 p-3';
                            container.style.zIndex = '1090';
                            document.body.appendChild(container);
                        }
                        
                        const toastEl = document.createElement('div');
                        toastEl.className = `toast align-items-center text-bg-${type === 'error' ? 'danger' : type}`;
                        toastEl.setAttribute('role', 'alert');
                        toastEl.innerHTML = `
                            <div class="d-flex">
                                <div class="toast-body">${message}</div>
                                <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
                            </div>
                        `;
                        
                        document.getElementById('toast-container').appendChild(toastEl);
                        const toast = new bootstrap.Toast(toastEl, { autohide: true, delay: 5000 });
                        toast.show();
                        
                        toastEl.addEventListener('hidden.bs.toast', () => toastEl.remove());
                    },
                    
                    formatDate,
                    
                    async loadFragments() {
                        if (!this.selectedSource) return;
                        
                        this.loadingFragments = true;
                        this.fragmentsError = null;
                        try {
                            this.fragments = await api.get(`/api/fragments/by-source/${this.selectedSource.id}`);
                        } catch (err) {
                            this.fragmentsError = 'Failed to load fragments: ' + err.message;
                            console.error('Error loading fragments:', err);
                        } finally {
                            this.loadingFragments = false;
                        }
                    },
                    
                    selectFragment(fragment) {
                        this.selectedFragment = fragment;
                    },
                    
                    async loadArticleTypes() {
                        try {
                            this.articleTypes = await api.get('/api/articles/types');
                        } catch (err) {
                            console.error('Error loading article types:', err);
                        }
                    },
                    
                    getFragmentCategoryIcon(category) {
                        if (!category) {
                            return 'bi-file-text';
                        }
                        
                        // Normalize: extract only alphabetic characters and convert to lowercase
                        const normalize = (str) => {
                            if (!str) return '';
                            return str.replace(/[^a-zA-Z]/g, '').toLowerCase();
                        };
                        
                        const normalizedCategory = normalize(category);
                        
                        // Hardcoded icon mappings
                        const hardcodedIcons = {
                            'bestpractices': 'bi-shield-check'
                        };
                        
                        if (hardcodedIcons[normalizedCategory]) {
                            return hardcodedIcons[normalizedCategory];
                        }
                        
                        // Match fragment category to article type by normalized name
                        if (this.articleTypes && this.articleTypes.length > 0) {
                            const matchingType = this.articleTypes.find(
                                at => at.name && normalize(at.name) === normalizedCategory
                            );
                            
                            if (matchingType && matchingType.icon) {
                                return matchingType.icon;
                            }
                        }
                        
                        // Default fallback
                        return 'bi-file-text';
                    },
                    
                    getIconClass(icon) {
                        if (!icon) {
                            return 'bi bi-file-text';
                        }
                        // If it's a Bootstrap Icon (starts with bi-), add bi base class
                        if (icon.startsWith('bi-')) {
                            return `bi ${icon}`;
                        }
                        // If it's a Font Awesome icon (starts with fa-), add fas (solid) base class
                        if (icon.startsWith('fa-')) {
                            return `fas ${icon}`;
                        }
                        // Default fallback
                        return 'bi bi-file-text';
                    }
                },
                
                async mounted() {
                    // Initialize markdown renderer
                    if (typeof marked !== 'undefined') {
                        this.markdownRenderer = marked;
                    } else {
                        console.error('Marked.js library not loaded');
                    }
                    
                    // Load article types for icon mapping
                    await this.loadArticleTypes();
                    
                    await this.loadSources();
                    
                    // Check URL for selected source ID
                    const urlParams = new URLSearchParams(window.location.search);
                    const sourceIdFromUrl = urlParams.get('id');
                    if (sourceIdFromUrl) {
                        const source = this.sources.find(s => s.id === sourceIdFromUrl);
                        if (source) {
                            await this.selectSource(source, true); // Use replaceState on initial load
                        }
                    }
                    
                    // Set up SignalR connection for real-time fragment extraction notifications
                    this.signalRConnection = createSignalRConnection('/integrationStatusHub');
                    
                    // Listen for fragment extraction completion
                    this.signalRConnection.on('FragmentExtractionComplete', async (sourceId, fragmentCount, success, message) => {
                        console.log('Fragment extraction complete:', { sourceId, fragmentCount, success, message });
                        
                        // Reload sources list to update fragment counts and extraction status in sidebar
                        await this.loadSources();
                        
                        // If this is the currently selected source, reload its details and fragments
                        if (this.selectedSource && this.selectedSource.id === sourceId) {
                            try {
                                const updatedSource = await api.get(`/api/sources/${sourceId}`);
                                this.selectedSource = updatedSource;
                                // Update extraction status from API response
                                this.extractionStatus[sourceId] = this.mapExtractionStatus(updatedSource.extractionStatus);
                                
                                // Reload fragments if extraction was successful
                                if (success) {
                                    await this.loadFragments();
                                }
                            } catch (err) {
                                console.error('Failed to reload source:', err);
                            }
                            
                            // Show notification for the selected source
                            if (success) {
                                this.showToast('success', message || `Successfully extracted ${fragmentCount} fragments`);
                            } else {
                                this.showToast('error', message || 'Fragment extraction failed');
                            }
                        }
                    });
                    
                    // Start the SignalR connection
                    try {
                        await this.signalRConnection.start();
                        console.log('SignalR connected for fragment notifications');
                    } catch (err) {
                        console.error('SignalR connection error:', err);
                    }
                },
                
                beforeUnmount() {
                    // Clean up SignalR connection
                    if (this.signalRConnection) {
                        this.signalRConnection.stop();
                    }
                }
            });
            
            // Mount the single app to #app which contains everything
            app.mount('#app');
        })(); // End of IIFE
    </script>
}
